# CVE-2021-3156

## Requirements

The vulnerable versions of sudo are legacy versions from 1.8.2 to 1.8.31p2 and all stable version from 1.9.0 to
1.9.5p1, in their default configuration.

This repositiory is tested on Ubuntu 20.04 (sudo 1.8.31). In it we open a terminal with root privileges.

## Analysis

If Sudo is executed to run a command in *shell* mode:
- Through the `-s` option, which set sudo's `MODE_SHELL` flags.
- Through the `-i` option, which sets sudo's `MODE_SHELL` and `MODE_LOGIN_SHELL` flags.

Then at the begining of sudo's `main()`, `parse_args()` rewrites argv, by concatenating all command-line arguments and
by escaping all meta-characters with backslashes.

```c
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
        char **av, *cmnd = NULL;
        int ac = 1;

            cmnd = dst = reallocarray(NULL, cmnd_size, 2);

            for (av = argv; *av != NULL; av++) {
                for (src = *av; *src != '\0'; src++) {
                    /* quote potential meta characters */
                    if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
                        *dst++ = '\\';
                    *dst++ = *src;
                }
                *dst++ = ' ';
            }
...
            ac += 2; /* -c cmnd */
...
        av = reallocarray(NULL, ac + 1, sizeof(char *));
...
        av[0] = (char *)user_details.shell; /* plugin may override shell */
        if (cmnd != NULL) {
            av[1] = "-c";
            av[2] = cmnd;
        }
        av[ac] = NULL;

        argv = av;
        argc = ac;
    }
```

Later, in `sudoers_policy_main()`, `set_cmnd()` concatenates the command-line arguments into a heap-based buffer
`user_args` and unescapes the meta-characters, "for sudoers matching and logging purposes":

```c
    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
...
             for (size = 0, av = NewArgv + 1; *av; av++)
                 size += strlen(*av) + 1;
             if (size == 0 || (user_args = malloc(size)) == NULL) {
...
             }
             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
...
                 for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                     while (*from) {
                         if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                             from++;
                         *to++ = *from++;
                     }
                     *to++ = ' ';
                 }
...
             }
...
     }
```

If a command-line argument ends with a single backlash character, then:
- `from[0]` is the backlash character and `from[1]` the null terminator
- `from` is incremented and points to the null terminator
- The null terminator is copied to the `user_args` buffer and `from` incremented again and points out of bounds
- The while loop reads and copies out-of-bounds characters to the `user_args` buffer.

# Exploitation

```
Program received signal SIGSEGV, Segmentation fault.

0x00007f6bf9c294ee in nss_load_library (ni=ni@entry=0x55cf1a1dd040) at nsswitch.c:344

=> 0x7f6bf9c294ee <nss_load_library+46>:        cmpq   $0x0,0x8(%rbx)

rbx            0x41414141414141    18367622009667905
```

The function crashing is `nss_load_library()` from glibc (at line 344) because the pointer `library` was overwritten.

```c
static int
nss_load_library (service_user *ni)
{
  if (ni->library == NULL)
    {

      ni->library = nss_new_service (service_table ?: &default_table,
                                     ni->name);

    }

  if (ni->library->lib_handle == NULL)
    {
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni->name) + 3
                      + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
                                              "libnss_"),
                                    ni->name),
                          ".so"),
                __nss_shlib_revision);

      ni->library->lib_handle = __libc_dlopen (shlib_name);
```

The steps to exploit this crash are the following:
- Overwrite `ni->library` with `NULL`. this will make the code enter the if clause and start the parsing and loading of
the library.
- Overwrite `ni->name` with `"X/X"`. This originally hold `"systemd"`.
- Therefore the `__strcpy` lines will parse `"libnss_X/X.so.2"` instead of `"libnss_systemd.so.2"`.
- We therfore are loading the shared library controlled by us `"libnss_X/X.so.2"` as root. In it we can do whatever we
wish as root.
